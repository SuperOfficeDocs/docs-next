---
import { readFile } from "fs/promises";
import path from "path";
import yaml from "js-yaml";
import type {
  headingsListProps,
  namespaceClassifiedDataProps,
} from "~/types/YamlManagedReferencesLayoutTypes";
import type { Item } from "~/types/YamlManagedReferencesTypes";
import YamlNamespace from "@components/YamlNamespace.astro";
import YamlClass from "@components/YamlClass.astro";
import type { TocData } from "~/types/TableOfContentTypes";
import ContentLayout from "@layouts/ContentLayout.astro";

interface Props {
  entry: any;
  tocData: TocData;
  collection: string;
  contentPath: string;
}

const { entry, tocData, collection, contentPath } = Astro.props;

const pageTitle = entry.data.items[0].type + " " + entry.data.items[0].id;

export const conversionList = {
  Class: "Classes",
  Constructor: "Constructors",
  Field: "Fields",
  Method: "Methods",
  Property: "Properties",
  Interface: "Interfaces",
  Implement: "Implements",
  Enum: "Enums",
};

const headingList: headingsListProps = {};
const namespaceData: namespaceClassifiedDataProps = {};

/**
 * Appends headings into headingList according to relevent key
 *
 * @param key - key of the heading to be included (ex: Class, Constructor, Enum)
 * @param dataItem - dataItem's extracted from the yml
 */
function appendIntoHeadingList(key: keyof headingsListProps, dataItem: Item) {
  if (!(key in headingList)) {
    headingList[key] = [];
  }
  headingList[key].push({
    text: getDataItemID(dataItem),
    slug: dataItem.uid,
  });
}

/**
 * Extracts the ID from a data item by returning either its 'id' property or the last segment of its 'uid' property.
 * @param {any} dataItem - The data item object containing either an 'id' or 'uid' property
 * @returns {string} The ID value from the data item
 */
function getDataItemID(dataItem: any): string {
  return dataItem.id ?? dataItem.uid?.split(".").pop();
}

const documentType = entry.data.items[0].type;

if (documentType === "Namespace") {
  const promises = entry.data.items[0].children?.map(
    async (childName: string) => {
      // Build absolute path for the child YAML file
      const baseContentPath = "external-content";
      const childFilePath = path.join(
        baseContentPath,
        contentPath,
        `${childName}.yml`
      );

      try {
        const raw = await readFile(childFilePath, "utf8");
        const parsed: any = yaml.load(raw);
        const dataItem = parsed.items[0];
        const key = dataItem.type as keyof namespaceClassifiedDataProps;

        if (!namespaceData[key]) {
          namespaceData[key] = [];
        }
        namespaceData[key].push({
          uid: dataItem.uid,
          id: getDataItemID(dataItem),
          summary: dataItem.summary,
        });

        appendIntoHeadingList(key, dataItem);
      } catch (e: any) {
        if (e.code === "ENOENT") {
          console.warn(`Skipped missing file: ${childFilePath}`);
        } else {
          console.warn(`[warn] Problem loading ${childFilePath}: ${e.message}`);
        }
      }
    }
  );

  await Promise.all(promises || []);
} else if (["Class", "Interface", "Enum"].includes(documentType)) {
  const otherItems = entry.data.items.slice(1);
  otherItems.forEach((dataItem: Item) => {
    const key = dataItem.type as keyof headingsListProps;
    appendIntoHeadingList(key, dataItem);
  });

  // Check if implements exist and add them to headingList
  if (entry.data.items[0].implements?.length > 0) {
    const key = "Implement" as keyof headingsListProps;
    entry.data.items[0].implements.forEach((item: string) => {
      if (!(key in headingList)) {
        headingList[key] = [];
      }
      headingList[key].push({
        text: item,
        slug: item,
      });
    });
  }
}

// Generate heading based on collected headings in headingList
const headings = [{ depth: 0, slug: "", text: "" }];
let ItemType: keyof headingsListProps;
for (ItemType in headingList) {
  if (headingList[ItemType].length > 0) {
    headings.push({
      depth: 2,
      slug: conversionList[ItemType as keyof typeof conversionList],
      text: conversionList[ItemType as keyof typeof conversionList],
    });
    headingList[ItemType].map((item) => {
      headings.push({ depth: 3, ...item });
    });
  }
}
---

<ContentLayout
  entry={entry}
  toc={tocData}
  isLearn={false}
  language="en"
  headings={headings}
>
  <div class="w-full overflow-x-hidden [&&]:not-prose">
    <h1 class="text-3xl md:text-4xl break-words mt-6 mb-6">{pageTitle}</h1>

    {
      documentType === "Namespace" && (
        <YamlNamespace namespaceData={namespaceData} />
      )
    }

    {
      ["Class", "Interface", "Enum"].includes(documentType) && (
        <YamlClass data={entry.data} />
      )
    }
  </div>
</ContentLayout>
