---
import { getEntry, type CollectionEntry } from "astro:content";
import type {
  headingsListProps,
  namespaceClassifiedDataProps,
} from "~/types/YamlManagedReferencesLayoutTypes";
import type { Item } from "~/types/YamlManagedReferencesTypes";
import YamlNamespace from "@components/YamlNamespace.astro";
import YamlClass from "@components/YamlClass.astro";
import type { TocData } from "~/types/TableOfContentTypes";
import ContentLayout from "@layouts/ContentLayout.astro";

import type { CollectionKey } from "astro:content";

interface Props {
  entry: CollectionEntry<
    "webapi" | "crmscript" | "web" | "netserver-core" | "netserver-services"
  >;
  tocData: TocData;
  collection: CollectionKey;
}

const { entry, tocData, collection } = Astro.props;

const pageTitle = entry.data.items[0].type + " " + entry.data.items[0].id;

// Use to get the plural forms of the name
export const conversionList = {
  Class: "Classes",
  Constructor: "Constructors",
  Field: "Fields",
  Method: "Methods",
  Property: "Properties",
  Interface: "Interfaces",
  Implement: "Implements",
  Enum: "Enums",
};

// Generate heading from yml data
const headingList: headingsListProps = {};
const namespaceData: namespaceClassifiedDataProps = {};

/**
 * Appends headings into headingList according to relevent key
 *
 * @param key - key of the heading to be included (ex: Class, Constructor, Enum)
 * @param dataItem - dataItem's extracted from the yml
 */
function appendIntoHeadingList(key: keyof headingsListProps, dataItem: Item) {
  if (!(key in headingList)) {
    headingList[key] = [];
  }
  headingList[key].push({
    text: dataItem.id,
    slug: dataItem.uid,
  });
}

const documentType = entry.data.items[0].type;
if (documentType == "Namespace") {
  const promises = entry.data.items[0].children?.map(
    async (childName: string) => {
      const formattedItem = childName.replaceAll(".", "").toLowerCase();
      const childrenItemEntry = await getEntry(collection, formattedItem);
      if (childrenItemEntry) {
        const dataItem = childrenItemEntry?.data.items[0];
        const key = dataItem.type as keyof namespaceClassifiedDataProps;
        if (!namespaceData[key]) {
          namespaceData[key] = [];
        }
        namespaceData[key].push({
          uid: dataItem.uid,
          id: dataItem.id,
          summary: dataItem.summary,
        });
        appendIntoHeadingList(key, dataItem);
      }
    }
  );

  await Promise.all(promises || []);
} else if (["Class", "Interface", "Enum"].includes(documentType)) {
  // Append headings of every other item except parent item to headingsList
  const otherItemsExceptParentItem = entry.data.items.slice(1);
  otherItemsExceptParentItem.forEach((dataItem: Item) => {
    const key = dataItem.type as keyof headingsListProps;
    appendIntoHeadingList(key, dataItem);
  });

  // Check if implements exist and add them to headingList
  if (
    entry.data.items[0].implements &&
    entry.data.items[0].implements.length > 0
  ) {
    const key = "Implement" as keyof headingsListProps;
    entry.data.items[0].implements.forEach((item: string) => {
      if (!(key in headingList)) {
        headingList[key] = [];
      }
      headingList[key].push({
        text: item,
        slug: item,
      });
    });
  }
}

// Generate heading based on collected headings in headingList
const headings = [{ depth: 0, slug: "", text: "" }];
let ItemType: keyof headingsListProps;
for (ItemType in headingList) {
  if (headingList[ItemType].length > 0) {
    headings.push({
      depth: 2,
      slug: conversionList[ItemType as keyof typeof conversionList],
      text: conversionList[ItemType as keyof typeof conversionList],
    });
    headingList[ItemType].map((item) => {
      headings.push({ depth: 3, ...item });
    });
  }
}
---

<ContentLayout
  entry={entry}
  toc={tocData}
  isLearn={false}
  language="en"
  headings={headings}
>
  <div class="w-full overflow-x-hidden [&&]:not-prose">
    <h1 class="text-3xl md:text-4xl break-words mt-6 mb-6">{pageTitle}</h1>

    {
      documentType == "Namespace" && (
        <YamlNamespace namespaceData={namespaceData} />
      )
    }

    {
      ["Class", "Interface", "Enum"].includes(documentType) && (
        <YamlClass data={entry.data} />
      )
    }
  </div>
</ContentLayout>
