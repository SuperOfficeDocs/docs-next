---
import { readFile } from "fs/promises";
import { glob } from "glob";
import path from "path";
import matter from "gray-matter";
import type { TocData } from "~/types/TableOfContentTypes";
import { getTocByPath } from "@utils/tocUtils";
import ContentLayout from "@layouts/ContentLayout.astro";
import { renderMarkdownWithHeadingIds } from "@utils/contentUtils";

export async function getStaticPaths() {
  const apiOnly = process.env.API_ONLY === 'true';

  if (!apiOnly) {
    return [];
  }

  const baseContentPath = "external-content";
  const referencePath = path.join(
    baseContentPath,
    "superoffice-docs/docs/en/api/reference"
  );

  // Function to create lazy loader for markdown content
  function loadMarkdownContent(filePath: string) {
    return async () => {
      const rawContent = await readFile(filePath, "utf8");
      const { data, content } = matter(rawContent);
      // Create a more complete entry object that matches content collection structure
      const relativePath = filePath.replace(
        "external-content/superoffice-docs/docs/",
        ""
      );
      const slug = relativePath.replace(/\.(md|mdx)$/, "");
      const { html, headings } = await renderMarkdownWithHeadingIds(content);

      return {
        data,
        body: content,
        filePath: filePath,
        html: html,
        headings,
        id: slug,
        collection: "en",
      };
    };
  }

  // Function to create lazy loader for TOC data
  function loadTocData(apiPath: string) {
    return async () => {
      try {
        const tocData = await getTocByPath(apiPath);
        return tocData;
      } catch (error) {
        console.warn(`Failed to load TOC data for path: ${apiPath}`, error);
        // Return a default/empty TOC structure instead of failing
        return {
          items: [],
        } as TocData;
      }
    };
  }

  try {
    // Temporary configured to exclude "soap" until github pages limitation is solved
    const pattern = [
      "superoffice-docs/docs/en/api/reference/restful/**/*.{md,mdx}",
      "superoffice-docs/docs/en/api/reference/{webapi,web,netserver}/**/*.{md,mdx}",
      "!**/includes/**/*.{md,mdx}",
    ];
    const filePaths = await glob(pattern, {
      cwd: baseContentPath,
      absolute: false,
    });

    if (filePaths.length === 0) {
      console.error("No files found! Check if the path exists:", referencePath);
      return [];
    }

    const tocLoaderCache = new Map<string, () => Promise<TocData>>();

    const paths = filePaths.map((relativePath) => {
      // Convert relative path to absolute path for file reading
      const absoluteFilePath = path.resolve(baseContentPath, relativePath);

      const normalizedPath = relativePath.replace(/\\/g, "/");
      
      // Generate slug from the relative path, removing base and extension
      // Remove "superoffice-docs/docs/en/api/reference/" and file extension to get clean slug
      const cleanPath = normalizedPath
        .replace("superoffice-docs/docs/en/api/reference", "")
        .replace(/\.(md|mdx)$/, "");
      const slug = cleanPath;

      const apiType = slug?.split("/")[1];
      const tocCollectionPath = `superoffice-docs/docs/en/api/reference/${apiType}`;

      // Cache the TOC loader function, not the data
      if (!tocLoaderCache.has(apiType)) {
        tocLoaderCache.set(apiType, loadTocData(tocCollectionPath));
      }

      return {
        params: { slug: slug },
        props: {
          loadEntry: loadMarkdownContent(absoluteFilePath),
          loadTocData: tocLoaderCache.get(apiType)!,
          apiType: apiType,
        },
      };
    });
    return paths;
  } catch (error) {
    console.error("Error in getStaticPaths:", error);
    return [];
  }
}

const { loadEntry, loadTocData, apiType } = Astro.props;

// Load the data when the page is being built
const entry = await loadEntry();
const tocData = await loadTocData();
---

<ContentLayout
  headings={entry.headings}
  htmlEntry={entry}
  toc={tocData}
  TOCBasePath={`en/api/reference/${apiType}`}
>
  <div class="prose max-w-none" set:html={entry.html} />
</ContentLayout>
